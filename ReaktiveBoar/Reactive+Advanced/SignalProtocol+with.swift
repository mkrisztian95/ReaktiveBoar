//! Autogenerated file
// swiftlint:disable large_tuple function_parameter_count file_length

//line_length

import ReactiveKit

public extension SignalProtocol where Element == Void {

    func with<U0>(
        _ value0: Value<U0>) -> Signal<(U0), Error> {
        return Signal { observer in
            return self.observe { event in
                switch event {
                case .next:
                    if
                        let val0 = value0.value {
                        observer.next( (val0) )
                    }
                case .failed(let error):
                    observer.failed(error)
                case .completed:
                    observer.completed()
                }
            }
        }
    }

    func with<U0, U1>(
        _ value0: Value<U0>,
        _ value1: Value<U1>) -> Signal<(U0, U1), Error> {
        return Signal { observer in
            return self.observe { event in
                switch event {
                case .next:
                    if
                        let val0 = value0.value,
                        let val1 = value1.value {
                        observer.next( (val0, val1) )
                    }
                case .failed(let error):
                    observer.failed(error)
                case .completed:
                    observer.completed()
                }
            }
        }
    }

    func with<U0, U1, U2>(
        _ value0: Value<U0>,
        _ value1: Value<U1>,
        _ value2: Value<U2>) -> Signal<(U0, U1, U2), Error> {
        return Signal { observer in
            return self.observe { event in
                switch event {
                case .next:
                    if
                        let val0 = value0.value,
                        let val1 = value1.value,
                        let val2 = value2.value {
                        observer.next( (val0, val1, val2) )
                    }
                case .failed(let error):
                    observer.failed(error)
                case .completed:
                    observer.completed()
                }
            }
        }
    }

    func with<U0, U1, U2, U3>(
        _ value0: Value<U0>,
        _ value1: Value<U1>,
        _ value2: Value<U2>,
        _ value3: Value<U3>) -> Signal<(U0, U1, U2, U3), Error> {
        return Signal { observer in
            return self.observe { event in
                switch event {
                case .next:
                    if
                        let val0 = value0.value,
                        let val1 = value1.value,
                        let val2 = value2.value,
                        let val3 = value3.value {
                        observer.next( (val0, val1, val2, val3) )
                    }
                case .failed(let error):
                    observer.failed(error)
                case .completed:
                    observer.completed()
                }
            }
        }
    }

    func with<U0, U1, U2, U3, U4>(
        _ value0: Value<U0>,
        _ value1: Value<U1>,
        _ value2: Value<U2>,
        _ value3: Value<U3>,
        _ value4: Value<U4>) -> Signal<(U0, U1, U2, U3, U4), Error> {
        return Signal { observer in
            return self.observe { event in
                switch event {
                case .next:
                    if
                        let val0 = value0.value,
                        let val1 = value1.value,
                        let val2 = value2.value,
                        let val3 = value3.value,
                        let val4 = value4.value {
                        observer.next( (val0, val1, val2, val3, val4) )
                    }
                case .failed(let error):
                    observer.failed(error)
                case .completed:
                    observer.completed()
                }
            }
        }
    }

    func with<U0, U1, U2, U3, U4, U5>(
        _ value0: Value<U0>,
        _ value1: Value<U1>,
        _ value2: Value<U2>,
        _ value3: Value<U3>,
        _ value4: Value<U4>,
        _ value5: Value<U5>) -> Signal<(U0, U1, U2, U3, U4, U5), Error> {
        return Signal { observer in
            return self.observe { event in
                switch event {
                case .next:
                    if
                        let val0 = value0.value,
                        let val1 = value1.value,
                        let val2 = value2.value,
                        let val3 = value3.value,
                        let val4 = value4.value,
                        let val5 = value5.value {
                        observer.next( (val0, val1, val2, val3, val4, val5) )
                    }
                case .failed(let error):
                    observer.failed(error)
                case .completed:
                    observer.completed()
                }
            }
        }
    }

    func with<U0, U1, U2, U3, U4, U5, U6>(
        _ value0: Value<U0>,
        _ value1: Value<U1>,
        _ value2: Value<U2>,
        _ value3: Value<U3>,
        _ value4: Value<U4>,
        _ value5: Value<U5>,
        _ value6: Value<U6>) -> Signal<(U0, U1, U2, U3, U4, U5, U6), Error> {
        return Signal { observer in
            return self.observe { event in
                switch event {
                case .next:
                    if
                        let val0 = value0.value,
                        let val1 = value1.value,
                        let val2 = value2.value,
                        let val3 = value3.value,
                        let val4 = value4.value,
                        let val5 = value5.value,
                        let val6 = value6.value {
                        observer.next( (val0, val1, val2, val3, val4, val5, val6) )
                    }
                case .failed(let error):
                    observer.failed(error)
                case .completed:
                    observer.completed()
                }
            }
        }
    }

    func with<U0, U1, U2, U3, U4, U5, U6, U7>(
        _ value0: Value<U0>,
        _ value1: Value<U1>,
        _ value2: Value<U2>,
        _ value3: Value<U3>,
        _ value4: Value<U4>,
        _ value5: Value<U5>,
        _ value6: Value<U6>,
        _ value7: Value<U7>) -> Signal<(U0, U1, U2, U3, U4, U5, U6, U7), Error> {
        return Signal { observer in
            return self.observe { event in
                switch event {
                case .next:
                    if
                        let val0 = value0.value,
                        let val1 = value1.value,
                        let val2 = value2.value,
                        let val3 = value3.value,
                        let val4 = value4.value,
                        let val5 = value5.value,
                        let val6 = value6.value,
                        let val7 = value7.value {
                        observer.next( (val0, val1, val2, val3, val4, val5, val6, val7) )
                    }
                case .failed(let error):
                    observer.failed(error)
                case .completed:
                    observer.completed()
                }
            }
        }
    }

    func with<U0, U1, U2, U3, U4, U5, U6, U7, U8>(
        _ value0: Value<U0>,
        _ value1: Value<U1>,
        _ value2: Value<U2>,
        _ value3: Value<U3>,
        _ value4: Value<U4>,
        _ value5: Value<U5>,
        _ value6: Value<U6>,
        _ value7: Value<U7>,
        _ value8: Value<U8>) -> Signal<(U0, U1, U2, U3, U4, U5, U6, U7, U8), Error> {
        return Signal { observer in
            return self.observe { event in
                switch event {
                case .next:
                    if
                        let val0 = value0.value,
                        let val1 = value1.value,
                        let val2 = value2.value,
                        let val3 = value3.value,
                        let val4 = value4.value,
                        let val5 = value5.value,
                        let val6 = value6.value,
                        let val7 = value7.value,
                        let val8 = value8.value {
                        observer.next( (val0, val1, val2, val3, val4, val5, val6, val7, val8) )
                    }
                case .failed(let error):
                    observer.failed(error)
                case .completed:
                    observer.completed()
                }
            }
        }
    }
}

public extension SignalProtocol {

    func with<U0>(
        _ value0: Value<U0>) -> Signal<(Element, U0), Error> {
        return Signal { observer in
            return self.observe { event in
                switch event {
                case .next(let element):
                    if
                        let val0 = value0.value {
                        observer.next( (element, val0) )
                    }
                case .failed(let error):
                    observer.failed(error)
                case .completed:
                    observer.completed()
                }
            }
        }
    }

    func with<U0, U1>(
        _ value0: Value<U0>,
        _ value1: Value<U1>) -> Signal<(Element, U0, U1), Error> {
        return Signal { observer in
            return self.observe { event in
                switch event {
                case .next(let element):
                    if
                        let val0 = value0.value,
                        let val1 = value1.value {
                        observer.next( (element, val0, val1) )
                    }
                case .failed(let error):
                    observer.failed(error)
                case .completed:
                    observer.completed()
                }
            }
        }
    }

    func with<U0, U1, U2>(
        _ value0: Value<U0>,
        _ value1: Value<U1>,
        _ value2: Value<U2>) -> Signal<(Element, U0, U1, U2), Error> {
        return Signal { observer in
            return self.observe { event in
                switch event {
                case .next(let element):
                    if
                        let val0 = value0.value,
                        let val1 = value1.value,
                        let val2 = value2.value {
                        observer.next( (element, val0, val1, val2) )
                    }
                case .failed(let error):
                    observer.failed(error)
                case .completed:
                    observer.completed()
                }
            }
        }
    }

    func with<U0, U1, U2, U3>(
        _ value0: Value<U0>,
        _ value1: Value<U1>,
        _ value2: Value<U2>,
        _ value3: Value<U3>) -> Signal<(Element, U0, U1, U2, U3), Error> {
        return Signal { observer in
            return self.observe { event in
                switch event {
                case .next(let element):
                    if
                        let val0 = value0.value,
                        let val1 = value1.value,
                        let val2 = value2.value,
                        let val3 = value3.value {
                        observer.next( (element, val0, val1, val2, val3) )
                    }
                case .failed(let error):
                    observer.failed(error)
                case .completed:
                    observer.completed()
                }
            }
        }
    }

    func with<U0, U1, U2, U3, U4>(
        _ value0: Value<U0>,
        _ value1: Value<U1>,
        _ value2: Value<U2>,
        _ value3: Value<U3>,
        _ value4: Value<U4>) -> Signal<(Element, U0, U1, U2, U3, U4), Error> {
        return Signal { observer in
            return self.observe { event in
                switch event {
                case .next(let element):
                    if
                        let val0 = value0.value,
                        let val1 = value1.value,
                        let val2 = value2.value,
                        let val3 = value3.value,
                        let val4 = value4.value {
                        observer.next( (element, val0, val1, val2, val3, val4) )
                    }
                case .failed(let error):
                    observer.failed(error)
                case .completed:
                    observer.completed()
                }
            }
        }
    }

    func with<U0, U1, U2, U3, U4, U5>(
        _ value0: Value<U0>,
        _ value1: Value<U1>,
        _ value2: Value<U2>,
        _ value3: Value<U3>,
        _ value4: Value<U4>,
        _ value5: Value<U5>) -> Signal<(Element, U0, U1, U2, U3, U4, U5), Error> {
        return Signal { observer in
            return self.observe { event in
                switch event {
                case .next(let element):
                    if
                        let val0 = value0.value,
                        let val1 = value1.value,
                        let val2 = value2.value,
                        let val3 = value3.value,
                        let val4 = value4.value,
                        let val5 = value5.value {
                        observer.next( (element, val0, val1, val2, val3, val4, val5) )
                    }
                case .failed(let error):
                    observer.failed(error)
                case .completed:
                    observer.completed()
                }
            }
        }
    }

    func with<U0, U1, U2, U3, U4, U5, U6>(
        _ value0: Value<U0>,
        _ value1: Value<U1>,
        _ value2: Value<U2>,
        _ value3: Value<U3>,
        _ value4: Value<U4>,
        _ value5: Value<U5>,
        _ value6: Value<U6>) -> Signal<(Element, U0, U1, U2, U3, U4, U5, U6), Error> {
        return Signal { observer in
            return self.observe { event in
                switch event {
                case .next(let element):
                    if
                        let val0 = value0.value,
                        let val1 = value1.value,
                        let val2 = value2.value,
                        let val3 = value3.value,
                        let val4 = value4.value,
                        let val5 = value5.value,
                        let val6 = value6.value {
                        observer.next( (element, val0, val1, val2, val3, val4, val5, val6) )
                    }
                case .failed(let error):
                    observer.failed(error)
                case .completed:
                    observer.completed()
                }
            }
        }
    }

    func with<U0, U1, U2, U3, U4, U5, U6, U7>(
        _ value0: Value<U0>,
        _ value1: Value<U1>,
        _ value2: Value<U2>,
        _ value3: Value<U3>,
        _ value4: Value<U4>,
        _ value5: Value<U5>,
        _ value6: Value<U6>,
        _ value7: Value<U7>) -> Signal<(Element, U0, U1, U2, U3, U4, U5, U6, U7), Error> {
        return Signal { observer in
            return self.observe { event in
                switch event {
                case .next(let element):
                    if
                        let val0 = value0.value,
                        let val1 = value1.value,
                        let val2 = value2.value,
                        let val3 = value3.value,
                        let val4 = value4.value,
                        let val5 = value5.value,
                        let val6 = value6.value,
                        let val7 = value7.value {
                        observer.next( (element, val0, val1, val2, val3, val4, val5, val6, val7) )
                    }
                case .failed(let error):
                    observer.failed(error)
                case .completed:
                    observer.completed()
                }
            }
        }
    }

    func with<U0, U1, U2, U3, U4, U5, U6, U7, U8>(
        _ value0: Value<U0>,
        _ value1: Value<U1>,
        _ value2: Value<U2>,
        _ value3: Value<U3>,
        _ value4: Value<U4>,
        _ value5: Value<U5>,
        _ value6: Value<U6>,
        _ value7: Value<U7>,
        _ value8: Value<U8>) -> Signal<(Element, U0, U1, U2, U3, U4, U5, U6, U7, U8), Error> {
        return Signal { observer in
            return self.observe { event in
                switch event {
                case .next(let element):
                    if
                        let val0 = value0.value,
                        let val1 = value1.value,
                        let val2 = value2.value,
                        let val3 = value3.value,
                        let val4 = value4.value,
                        let val5 = value5.value,
                        let val6 = value6.value,
                        let val7 = value7.value,
                        let val8 = value8.value {
                        observer.next( (element, val0, val1, val2, val3, val4, val5, val6, val7, val8) )
                    }
                case .failed(let error):
                    observer.failed(error)
                case .completed:
                    observer.completed()
                }
            }
        }
    }
}
